<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>SWI-Prolog cplint Pack Manual</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.tug.org/tex4ht/)"> 
<!-- html --> 
<meta name="src" content="manual.tex"> 
<meta name="date" content="2016-01-10 00:06:00"> 
<link rel="stylesheet" type="text/css" href="manual.css"> 
</head><body 
>
   <div class="maketitle">



<h2 class="titleHead">SWI-Prolog cplint Pack Manual</h2>
    <div class="author" ><span 
class="cmr-12">Fabrizio Riguzzi</span>
<br /><span 
class="cmr-12">fabrizio.riguzzi@unife.it</span></div><br />
<div class="date" ><span 
class="cmr-12">January 10, 2016</span></div>
   </div>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Introduction</h3>
<!--l. 31--><p class="noindent" ><span 
class="cmtt-10">cplint </span>is a suite of programs for reasoning with LPADs/CP-logic programs
<span class="cite">[<a 
href="#XVenVer03-TR">10</a>,&#x00A0;<a 
href="#XVenVer04-ICLP04-IC">11</a>,&#x00A0;<a 
href="#XVenDenBru-JELIA06">8</a>,&#x00A0;<a 
href="#XDBLP:journals/tplp/VennekensDB09">9</a>]</span>. It contains modules for both inference and learning.
<!--l. 33--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>Installation</h3>
<!--l. 34--><p class="noindent" ><span 
class="cmtt-10">cplint </span>is distributed as a pack of SWI-Prolog. To install it, use

   <div class="verbatim" id="verbatim-1">
?-&#x00A0;pack_install(cplint).
</div>
<!--l. 37--><p class="nopar" > Moreover, in order to make sure you have a foreign library that matches your
architecture, run

   <div class="verbatim" id="verbatim-2">
?-&#x00A0;&#x00A0;pack_rebuild(cplint).
</div>
<!--l. 41--><p class="nopar" >
<!--l. 44--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-30003"></a>Syntax</h3>
<!--l. 46--><p class="noindent" >LPAD and CP-logic programs consist of a set of annotated disjunctive clauses.
Disjunction in the head is represented with a semicolon and atoms in the head are
separated from probabilities by a colon. For the rest, the usual syntax of Prolog is
used. A general CP-logic clause has the form

   <div class="verbatim" id="verbatim-3">
h1:p1&#x00A0;;&#x00A0;...&#x00A0;;&#x00A0;hn:pn&#x00A0;:-&#x00A0;b1,...,bm,\+&#x00A0;c1,....,\+&#x00A0;cl
</div>
<!--l. 51--><p class="nopar" > No parentheses are necessary. The <span 
class="cmtt-10">pi </span>are numeric expressions. It is up to the user to
ensure that the numeric expressions are legal, i.e. that they sum up to less than
one.
<!--l. 54--><p class="indent" >   If the clause has an empty body, it can be represented like this

   <div class="verbatim" id="verbatim-4">
h1:p1&#x00A0;;&#x00A0;...&#x00A0;;&#x00A0;hn:pn.
</div>
<!--l. 57--><p class="nopar" > If the clause has a single head with probability 1, the annotation can be omitted and
the clause takes the form of a normal prolog clause, i.e.

   <div class="verbatim" id="verbatim-5">
h1&#x00A0;:-&#x00A0;b1,...,bm,\+&#x00A0;c1,...,\+&#x00A0;cl.
</div>
<!--l. 61--><p class="nopar" > stands for

   <div class="verbatim" id="verbatim-6">
h1:1&#x00A0;:-&#x00A0;b1,...,bm,\+&#x00A0;c1,...,\+&#x00A0;cl.
</div>
<!--l. 65--><p class="nopar" > The coin example of <span class="cite">[<a 
href="#XVenVer04-ICLP04-IC">11</a>]</span> is represented as (file <span 
class="cmtt-10">coin.cpl</span>)

   <div class="verbatim" id="verbatim-7">
heads(Coin):1/2&#x00A0;;&#x00A0;tails(Coin):1/2&#x00A0;:-
&#x00A0;<br />&#x00A0;&#x00A0;toss(Coin),\+biased(Coin).
&#x00A0;<br />
&#x00A0;<br />heads(Coin):0.6&#x00A0;;&#x00A0;tails(Coin):0.4&#x00A0;:-
&#x00A0;<br />&#x00A0;&#x00A0;toss(Coin),biased(Coin).
&#x00A0;<br />
&#x00A0;<br />fair(Coin):0.9&#x00A0;;&#x00A0;biased(Coin):0.1.
&#x00A0;<br />
&#x00A0;<br />toss(coin).
</div>
<!--l. 77--><p class="nopar" > The first clause states that if we toss a coin that is not biased it has equal
probability of landing heads and tails. The second states that if the coin is biased it
has a slightly higher probability of landing heads. The third states that the coin is
fair with probability 0.9 and biased with probability 0.1 and the last clause states
that we toss a coin with certainty.
<!--l. 80--><p class="indent" >   Moreover, the bodies of rules may contain the built-in predicates:

   <div class="verbatim" id="verbatim-8">
is/2,&#x00A0;&#x003E;/2,&#x00A0;&#x003C;/2,&#x00A0;&#x003E;=/2&#x00A0;,=&#x003C;/2,
&#x00A0;<br />=:=/2,&#x00A0;=\=/2,&#x00A0;true/0,&#x00A0;false/0,
&#x00A0;<br />=/2,&#x00A0;==/2,&#x00A0;\=/2&#x00A0;,\==/2,&#x00A0;length/2
</div>
<!--l. 85--><p class="nopar" > The bodies may also contain the following library predicates:

   <div class="verbatim" id="verbatim-9">
member/2,&#x00A0;max_list/2,&#x00A0;min_list/2
&#x00A0;<br />nth0/3,&#x00A0;nth/3,&#x00A0;dif/2,&#x00A0;select/3
</div>
<!--l. 91--><p class="nopar" > plus the predicate

   <div class="verbatim" id="verbatim-10">
average/2
</div>
<!--l. 95--><p class="nopar" > that, given a list of numbers, computes its arithmetic mean.
<!--l. 98--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-40004"></a>Inference</h3>
<!--l. 99--><p class="noindent" ><span 
class="cmtt-10">cplint </span>answers queries using the module <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">pita</span></span></span>. It performs the program
transformation technique of <span class="cite">[<a 
href="#XRigSwi10-ICLP10-IC">7</a>]</span>. Differently from that work, techniques alternative to
tabling and answer subsumption are used.
<!--l. 104--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">4.1   </span> <a 
 id="x1-50004.1"></a>Commands</h4>
<!--l. 130--><p class="noindent" >You have to prepare a Prolog file where you first load <span 
class="cmtt-10">pita </span>and then enclose the
probabilistic clauses in <span 
class="cmtt-10">:-cplint. </span>and <span 
class="cmtt-10">:-end</span><span 
class="cmtt-10">_cplint. </span>For example, the coin
program above can be stored in <span 
class="cmtt-10">coin.pl </span>as follows

   <div class="verbatim" id="verbatim-11">
:-&#x00A0;use_module(library(pita)).
&#x00A0;<br />:-&#x00A0;cplint.
&#x00A0;<br />
&#x00A0;<br />heads(Coin):1/2&#x00A0;;&#x00A0;tails(Coin):1/2:-
&#x00A0;<br />toss(Coin),\+biased(Coin).
&#x00A0;<br />
&#x00A0;<br />heads(Coin):0.6&#x00A0;;&#x00A0;tails(Coin):0.4:-
&#x00A0;<br />toss(Coin),biased(Coin).
&#x00A0;<br />
&#x00A0;<br />fair(Coin):0.9&#x00A0;;&#x00A0;biased(Coin):0.1.
&#x00A0;<br />
&#x00A0;<br />toss(coin).
&#x00A0;<br />
&#x00A0;<br />:-end_cplint.
</div>
<!--l. 147--><p class="nopar" >
<!--l. 151--><p class="indent" >   Then you can simply load <span 
class="cmtt-10">coin.pl </span>as

   <div class="verbatim" id="verbatim-12">
?-[coin].
</div>
<!--l. 154--><p class="nopar" > and query it with

   <div class="verbatim" id="verbatim-13">
?-&#x00A0;prob(heads(coin),P).
</div>
<!--l. 158--><p class="nopar" > Note that supplying <span 
class="cmtt-10">coin.pl </span>as an argument to the command <span 
class="cmtt-10">swipl </span>currently
returns errors due to bad interaction between <span 
class="cmtt-10">pita.pl </span>and the top-level. The
program is loaded correctly anyway but it is recommended to load programs from the
top-level to avoid these errors.
<!--l. 164--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">4.1.1   </span> <a 
 id="x1-60004.1.1"></a>Parameters</h5>
<!--l. 165--><p class="noindent" >The module make use of a number of parameters in order to control its behavior.
They can be set with the directive

   <div class="verbatim" id="verbatim-14">
:-&#x00A0;set_pita(parameter,value).
</div>
<!--l. 168--><p class="nopar" > inside the couple <span 
class="cmtt-10">:-cplint. </span>and <span 
class="cmtt-10">:-end</span><span 
class="cmtt-10">_cplint.</span>
<!--l. 171--><p class="indent" >   The current value can be read with

   <div class="verbatim" id="verbatim-15">
setting_pita(parameter,Value).
</div>
<!--l. 174--><p class="nopar" > from the top-level. The available parameters are:
     <ul class="itemize1">
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">epsilon_parsing</span></span></span>: if (1 - the sum of the probabilities of all the head atoms)
     is smaller than <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">epsilon_parsing</span></span></span>, then <span 
class="cmtt-10">pita </span>adds the null event to the
     head. Default value <span 
class="cmtt-10">0.00001</span>.
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">single_var</span></span></span>:  determines  how  non  ground  clauses  are  treated:  if  <span 
class="cmtt-10">true</span>,
     a single random variable is assigned to the whole non ground clause, if
     <span 
class="cmtt-10">false</span>, a different random variable is assigned to every grounding of the
     clause. Default value <span 
class="cmtt-10">false</span>.
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">depth_bound</span></span></span>: if <span 
class="cmtt-10">true</span>, the depth of the derivation of the goal is limited to
     the value of the <span 
class="cmtt-10">depth </span>parameter. Default value <span 
class="cmtt-10">false</span>.
     </li>
     <li class="itemize"><span 
class="cmtt-10">depth</span>: maximum depth of derivations when <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">depth_bound</span></span></span> is set to <span 
class="cmtt-10">true</span>.
     Default value <span 
class="cmtt-10">2</span>.</li></ul>
<!--l. 191--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-70005"></a>Learning</h3>
<!--l. 192--><p class="noindent" ><span 
class="cmtt-10">cplint </span>contains the following learning algorithms:
     <ul class="itemize1">
     <li class="itemize">EMBLEM  (EM  over  Bdds  for  probabilistic  Logic  programs  Efficient
     Mining): an implementation of EM for learning parameters that computes
     expectations directly on BDDs <span class="cite">[<a 
href="#XBelRig11-IDA">3</a>,&#x00A0;<a 
href="#XBelRig11-CILC11-NC">1</a>,&#x00A0;<a 
href="#XBelRig11-TR">2</a>]</span>
     </li>
     <li class="itemize">SLIPCOVER  (Structure  LearnIng  of  Probabilistic  logic  programs  by
     searChing OVER the clause space): an algorithm for learning the structure
     of programs by searching the clause space and the theory space separately
     <span class="cite">[<a 
href="#XBelRig13-TPLP-IJ">4</a>]</span></li></ul>

<!--l. 198--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1   </span> <a 
 id="x1-80005.1"></a>Input</h4>
<!--l. 199--><p class="noindent" >To execute the learning algorithms, prepare a Prolog file divided in five
parts
     <ul class="itemize1">
     <li class="itemize">preamble
     </li>
     <li class="itemize">background knowledge, i.e., knowledge valid for all interpretations
     </li>
     <li class="itemize">LPAD for you which you want to learn the parameters (optional)
     </li>
     <li class="itemize">language bias information
     </li>
     <li class="itemize">example interpretations</li></ul>
<!--l. 207--><p class="noindent" >The preamble must come first, the order of the other parts can be changed.
<!--l. 209--><p class="indent" >   For example, consider the Bongard problems of <span class="cite">[<a 
href="#XRaeLae95-ALT95">6</a>]</span>. The <span 
class="cmtt-10">pack/cplint/</span>
<span 
class="cmtt-10">prolog/examples/learning </span>folder in SWI-Prolog home contains some example files
for learning. For example, it contains <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">bongard.pl</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">bongardkeys.pl</span></span></span> that
represent a Bongard problem. Let us consider <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">bongard.pl</span></span></span>.
<!--l. 214--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.1.1   </span> <a 
 id="x1-90005.1.1"></a>Preamble</h5>
<!--l. 215--><p class="noindent" >In the preamble, the SLIPCOVER library is loaded with

   <div class="verbatim" id="verbatim-16">
:-&#x00A0;use_module(library(slipcover)).
</div>
<!--l. 218--><p class="nopar" > Then, if you are using your file in cplint on SWISH, you could add

   <div class="verbatim" id="verbatim-17">
:-&#x00A0;if(current_predicate(use_rendering/1)).
&#x00A0;<br />:-&#x00A0;use_rendering(c3).
&#x00A0;<br />:-&#x00A0;use_rendering(lpad).
&#x00A0;<br />:-&#x00A0;endif.
</div>
<!--l. 225--><p class="nopar" > if you want a nice representation of the output (in particular, if you want graphs of
the ROC and PR curves).
<!--l. 228--><p class="indent" >   Now you can initialize SLIPCOVER with

   <div class="verbatim" id="verbatim-18">
:-sc.
</div>
<!--l. 231--><p class="nopar" > At this point you can start setting parameters for SLIPCOVER such as for
example

   <div class="verbatim" id="verbatim-19">
:-&#x00A0;set_sc(megaex_bottom,20).
&#x00A0;<br />:-&#x00A0;set_sc(max_iter,2).
&#x00A0;<br />:-&#x00A0;set_sc(max_iter_structure,5).
&#x00A0;<br />:-&#x00A0;set_sc(verbosity,1).
</div>
<!--l. 238--><p class="nopar" > We will see later the list of available parameters. This ends the preamble.
<!--l. 242--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.1.2   </span> <a 
 id="x1-100005.1.2"></a>Backgroung and Initial LPAD</h5>
<!--l. 244--><p class="noindent" >Now you can specify the background knowledge with a fact of the form

   <div class="verbatim" id="verbatim-20">
bg([&#x003C;list&#x00A0;of&#x00A0;terms&#x00A0;representing&#x00A0;clauses]).
</div>
<!--l. 248--><p class="nopar" > and an initial program with a fact of the form

   <div class="verbatim" id="verbatim-21">
in([&#x003C;list&#x00A0;of&#x00A0;terms&#x00A0;representing&#x00A0;clauses]).
</div>
<!--l. 252--><p class="nopar" > The initial program is used in parameter learning for providing the structure. The
indicated parameters do not matter as they are first randomized. Remember to
enclose each clause in parentheses because <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">:-</span></span></span> has the highest precedence.
<!--l. 257--><p class="indent" >   For example, <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">bongard.pl</span></span></span> has the initial program

   <div class="verbatim" id="verbatim-22">
in([(pos:0.197575&#x00A0;:-
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;circle(A),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;in(B,A)),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(pos:0.000303421&#x00A0;:-
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;circle(A),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;triangle(B)),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;(pos:0.000448807&#x00A0;:-
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;triangle(A),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;circle(B))]).
</div>
<!--l. 268--><p class="nopar" > Both facts should be present. If there are no background/input clauses then write
<span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">bg([]).</span></span></span> or <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">in([]).</span></span></span>
<!--l. 272--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.1.3   </span> <a 
 id="x1-110005.1.3"></a>Language Bias</h5>
<!--l. 274--><p class="noindent" >The language bias part contains the declarations of the input and output predicates.
Output predicates are declared as

   <div class="verbatim" id="verbatim-23">
output(&#x003C;predicate&#x003E;/&#x003C;arity&#x003E;).
</div>
<!--l. 278--><p class="nopar" > and define the predicates whose atoms in the input interpretations are used as the
goals for the prediction of which you want to optimize the parameters. Derivations
for these goals are built by the systems.
<!--l. 281--><p class="indent" >   Input predicates are those for the predictions of which you do not want to
optimize the parameters. You can declare closed world input predicates
with

   <div class="verbatim" id="verbatim-24">
input_cw(&#x003C;predicate&#x003E;/&#x003C;arity&#x003E;).
</div>
<!--l. 284--><p class="nopar" > For these predicates, the only true atoms are those in the interpretations, the
clauses in the input program are not used to derive atoms not present in the
interpretations.
<!--l. 287--><p class="indent" >   Open world input predicates are declared with

   <div class="verbatim" id="verbatim-25">
input(&#x003C;predicate&#x003E;/&#x003C;arity&#x003E;).
</div>
<!--l. 290--><p class="nopar" > In this case, if a subgoal for such a predicate is encountered when deriving the atoms
for the output predicates, both the facts in the interpretations and the clauses of the
input program are used.
<!--l. 294--><p class="indent" >   Then, you have to specify the language bias by means of mode declarations in the
style of <a 
href="http://www.doc.ic.ac.uk/~shm/progol.html" > Progol </a>.

   <div class="verbatim" id="verbatim-26">
modeh(&#x003C;recall&#x003E;,&#x003C;predicate&#x003E;(&#x003C;arg1&#x003E;,...).
</div>
<!--l. 298--><p class="nopar" > specifies the atoms that can appear in the head of clauses, while

   <div class="verbatim" id="verbatim-27">
modeb(&#x003C;recall&#x003E;,&#x003C;predicate&#x003E;(&#x003C;arg1&#x003E;,...).
</div>
<!--l. 302--><p class="nopar" > specifies the atoms that can appear in the body of clauses. <span 
class="cmtt-10">&#x003C;recall&#x003E; </span>can
be an integer or <span 
class="cmtt-10">*</span>. <span 
class="cmtt-10">&#x003C;recall&#x003E; </span>indicates how many atoms for the predicate
specification are retained in the bottom clause during a saturation step. <span 
class="cmtt-10">* </span>stands
for all those that are found. Otherwise the indicated number is randomly
chosen.
<!--l. 308--><p class="indent" >   The arguments are of the form

   <div class="verbatim" id="verbatim-28">
+&#x003C;type&#x003E;
</div>
<!--l. 311--><p class="nopar" > for specifying that the argument should be an input variable of type <span 
class="cmtt-10">&#x003C;type&#x003E;</span>, i.e., a
variable replacing a <span 
class="cmtt-10">+&#x003C;type&#x003E; </span>argument in the head or a <span 
class="cmtt-10">-&#x003C;type&#x003E; </span>argument in a
preceding literal in the current hypothesized clause.
<!--l. 314--><p class="indent" >   Another argument form is

   <div class="verbatim" id="verbatim-29">
-&#x003C;type&#x003E;
</div>
<!--l. 317--><p class="nopar" > for specifying that the argument should be replace by a output variable of type
<span 
class="cmtt-10">&#x003C;type&#x003E;</span>. Any variable can replace this argument, either input or output.
The only constraint on output variables is that those in the head of the
current hypothesized clause must appear as output variables in an atom of the
body.
<!--l. 323--><p class="indent" >   Other forms are

   <div class="verbatim" id="verbatim-30">
#&#x003C;type&#x003E;
</div>
<!--l. 326--><p class="nopar" > for specifying an argument which should be replaced by a constant of type <span 
class="cmtt-10">&#x003C;type&#x003E; </span>in
the bottom clause but should not be used for replacing input variables of the
following literals or

   <div class="verbatim" id="verbatim-31">
-#&#x003C;type&#x003E;
</div>
<!--l. 330--><p class="nopar" > for specifying an argument which should be replaced by a constant of type <span 
class="cmtt-10">&#x003C;type&#x003E; </span>in
the bottom clause and that should be used for replacing input variables of
the following literals. <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">#</span></span></span> and <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">-#</span></span></span> differ only in the creation of the bottom
clause.

   <div class="verbatim" id="verbatim-32">
&#x003C;constant&#x003E;
</div>
<!--l. 334--><p class="nopar" > for specifying a constant.
<!--l. 337--><p class="indent" >   An example of language bias for the Bongard domain is

   <div class="verbatim" id="verbatim-33">
output(pos/0).
&#x00A0;<br />
&#x00A0;<br />input_cw(triangle/1).
&#x00A0;<br />input_cw(square/1).
&#x00A0;<br />input_cw(circle/1).
&#x00A0;<br />input_cw(in/2).
&#x00A0;<br />input_cw(config/2).
&#x00A0;<br />
&#x00A0;<br />modeh(*,pos).
&#x00A0;<br />modeb(*,triangle(-obj)).
&#x00A0;<br />modeb(*,square(-obj)).
&#x00A0;<br />modeb(*,circle(-obj)).
&#x00A0;<br />modeb(*,in(+obj,-obj)).
&#x00A0;<br />modeb(*,in(-obj,+obj)).
&#x00A0;<br />modeb(*,config(+obj,-#dir)).
</div>
<!--l. 354--><p class="nopar" > SLIPCOVER also requires facts for the <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">determination/2</span></span></span> predicate in Aleph
style that indicate which predicates can appear in the body of clauses. For
example

   <div class="verbatim" id="verbatim-34">
determination(pos/0,triangle/1).
&#x00A0;<br />determination(pos/0,square/1).
&#x00A0;<br />determination(pos/0,circle/1).
&#x00A0;<br />determination(pos/0,in/2).
&#x00A0;<br />determination(pos/0,config/2).
</div>
<!--l. 363--><p class="nopar" > state that <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">triangle/1</span></span></span> can appear in the body of clauses for <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">pos/0</span></span></span>.
<!--l. 366--><p class="indent" >   SLIPCOVER also allows mode declarations of the form

   <div class="verbatim" id="verbatim-35">
modeh(&#x003C;r&#x003E;,[&#x003C;s1&#x003E;,...,&#x003C;sn&#x003E;],[&#x003C;a1&#x003E;,...,&#x003C;an&#x003E;],[&#x003C;P1/Ar1&#x003E;,...,&#x003C;Pk/Ark&#x003E;]).
</div>
<!--l. 369--><p class="nopar" > These mode declarations are used to generate clauses with more than two head
atoms. In them, <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;s1&#x003E;,...,&#x003C;sn&#x003E;</span></span></span> are schemas, <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;a1&#x003E;,...,&#x003C;an&#x003E;</span></span></span> are atoms such that
<span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;ai&#x003E;</span></span></span> is obtained from <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;si&#x003E;</span></span></span> by replacing placemarkers with variables, <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;Pi/Ari&#x003E;</span></span></span> are
the predicates admitted in the body. <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;a1&#x003E;,...,&#x003C;an&#x003E;</span></span></span> are used to indicate which
variables should be shared by the atoms in the head. An example of such a mode
declaration (from <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">uwcselearn.pl</span></span></span>) is

   <div class="verbatim" id="verbatim-36">
modeh(*,
&#x00A0;<br />[advisedby(+person,+person),tempadvisedby(+person,+person)],
&#x00A0;<br />[advisedby(A,B),tempadvisedby(A,B)],
&#x00A0;<br />[professor/1,student/1,hasposition/2,inphase/2,
&#x00A0;<br />publication/2,taughtby/3,ta/3,courselevel/2,yearsinprogram/2]).
</div>
<!--l. 379--><p class="nopar" >
<!--l. 381--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.1.4   </span> <a 
 id="x1-120005.1.4"></a>Example Interpretations</h5>
<!--l. 382--><p class="noindent" >The last part of the file contains the data. You can specify data with two
modalities: models and keys. In the models type, you specify an example
model (or interpretation or megaexample) as a list of Prolog facts initiated
by <span 
class="cmtt-10">begin(model(&#x003C;name&#x003E;)). </span>and terminated by <span 
class="cmtt-10">end(model(&#x003C;name&#x003E;)). </span>as
in

   <div class="verbatim" id="verbatim-37">
begin(model(2)).
&#x00A0;<br />pos.
&#x00A0;<br />triangle(o5).
&#x00A0;<br />config(o5,up).
&#x00A0;<br />square(o4).
&#x00A0;<br />in(o4,o5).
&#x00A0;<br />circle(o3).
&#x00A0;<br />triangle(o2).
&#x00A0;<br />config(o2,up).
&#x00A0;<br />in(o2,o3).
&#x00A0;<br />triangle(o1).
&#x00A0;<br />config(o1,up).
&#x00A0;<br />end(model(2)).
</div>
<!--l. 401--><p class="nopar" > The interpretations may contain a fact of the form

   <div class="verbatim" id="verbatim-38">
prob(0.3).
</div>
<!--l. 405--><p class="nopar" > assigning a probability (0.3 in this case) to the interpretations. If this is omitted, the
probability of each interpretation is considered equal to 1<span 
class="cmmi-10">&#x2215;n </span>where <span 
class="cmmi-10">n </span>is the total
number of interpretations. <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">prob/1</span></span></span> can be used to set a different multiplicity for the
interpretations.
<!--l. 408--><p class="indent" >   The facts in the interpretation are loaded in SWI-Prolog database by adding an
extra initial argument equal to the name of the model.
<!--l. 410--><p class="indent" >   Alternatively, with the keys modality, you can directly write the facts and the
first argument will be interpreted as a model identifier. The above interpretation in
the keys modality is

   <div class="verbatim" id="verbatim-39">
pos(2).
&#x00A0;<br />triangle(2,o5).
&#x00A0;<br />config(2,o5,up).
&#x00A0;<br />square(2,o4).
&#x00A0;<br />in(2,o4,o5).
&#x00A0;<br />circle(2,o3).
&#x00A0;<br />triangle(2,o2).
&#x00A0;<br />config(2,o2,up).
&#x00A0;<br />in(2,o2,o3).
&#x00A0;<br />triangle(2,o1).
&#x00A0;<br />config(2,o1,up).
</div>
<!--l. 423--><p class="nopar" > which is contained in the <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">bongardkeys.pl</span></span></span> This is also how model <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">1</span></span></span> above is stored
in SWI-Prolog database.
<!--l. 427--><p class="indent" >   The two modalities, models and keys, can be mixed in the same file.
<!--l. 429--><p class="indent" >   Note that you can add background knowledge that is not probabilistic directly to
the file writing the clauses taking into account the model argument. For example
<span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">carc.pl</span></span></span> contains

   <div class="verbatim" id="verbatim-40">
connected(_M,Ring1,Ring2):-
&#x00A0;<br />&#x00A0;&#x00A0;Ring1&#x00A0;\=&#x00A0;Ring2,
&#x00A0;<br />&#x00A0;&#x00A0;member(A,Ring1),
&#x00A0;<br />&#x00A0;&#x00A0;member(A,Ring2),&#x00A0;!.
&#x00A0;<br />
&#x00A0;<br />symbond(Mod,A,B,T):-&#x00A0;bond(Mod,A,B,T).
&#x00A0;<br />symbond(Mod,A,B,T):-&#x00A0;bond(Mod,B,A,T).
</div>
<!--l. 440--><p class="nopar" > where the first argument of all the atoms is the model.
<!--l. 443--><p class="indent" >   Then you must indicate how the examples are divided in folds with facts
of the form: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">fold(&#x003C;fold_name&#x003E;,&#x003C;list</span><span 
class="cmtt-10">&#x00A0;of</span><span 
class="cmtt-10">&#x00A0;model</span><span 
class="cmtt-10">&#x00A0;identifiers&#x003E;)</span></span></span>, as for
example

   <div class="verbatim" id="verbatim-41">
fold(train,[2,3,...]).
&#x00A0;<br />fold(test,[490,491,...]).
</div>
<!--l. 448--><p class="nopar" >
   <h4 class="subsectionHead"><span class="titlemark">5.2   </span> <a 
 id="x1-130005.2"></a>Parameters</h4>
<!--l. 450--><p class="noindent" >Parameters are set with commands of the form

   <div class="verbatim" id="verbatim-42">
:-&#x00A0;set_sc(&#x003C;parameter&#x003E;,&#x003C;value&#x003E;).
</div>
<!--l. 453--><p class="nopar" > The available parameters are:
     <ul class="itemize1">
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">depth</span></span></span> (values: integer or <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">inf</span></span></span>, default value: 2, , valid for EMBLEM and
     SLIPCOVER): depth of derivations if <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">depth_bound</span></span></span> is set to <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">true</span></span></span>
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">single_var</span></span></span> (values:  <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">{true,false}</span></span></span>,  default  value:  <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">false</span></span></span>,  valid  for
     EMBLEM and SLIPCOVER): if set to <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">true</span></span></span>, there is a random variable
     for each clause, instead of a different random variable for each grounding
     of each clause
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">epsilon_em</span></span></span> (values:  real,  default  value:  0.1,  valid  for  EMBLEM  and
     SLIPCOVER): if the difference in the log likelihood in two successive
     parameter EM iteration is smaller than <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">epsilon_em</span></span></span>, then EM stops
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">epsilon_em_fraction</span></span></span>         (values:              real,              default
     value: 0.01, valid for EMBLEM and SLIPCOVER): if the difference in the
     log likelihood in two successive parameter EM iteration is smaller than
     <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">epsilon_em_fraction</span></span></span>*(-current log likelihood), then EM stops
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">iter</span></span></span>  (values:   integer,   defualt   value:   1,   valid   for   EMBLEM   and
     SLIPCOVER): maximum number of iteration of EM parameter learning.
     If set to -1, no maximum number of iterations is imposed
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">iterREF</span></span></span> (values:  integer,  defualt  value:  1,  valid  for  SLIPCOVER):
     maximum number of iteration of EM parameter learning for refinements.
     If set to -1, no maximum number of iterations is imposed.
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">random_restarts_number</span></span></span> (values:  integer,  default  value:  1,  valid  for
     EMBLEM and SLIPCOVER): number of random restarts of parameter
     EM learning
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">random_restarts_REFnumber</span></span></span> (values: integer, default value: 1, valid for
     SLIPCOVER): number of random restarts of parameter EM learning for
     refinements

     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">setrand</span></span></span> (values:  rand(integer,integer,integer),  valid  for  EMBLEM  and
     SLIPCOVER): seed for the random functions, see Yap manual for allowed
     values
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">logzero</span></span></span> (values:  negative  real,  default  value  log(0<span 
class="cmmi-10">.</span>000001),  valid  for
     SLIPCOVER): value assigned to log 0
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">max_iter</span></span></span> (values:  integer,  default  value:  10,  valid  for  SLIPCOVER):
     number of interations of beam search
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">max_var</span></span></span> (values:  integer,  default  value:  4,  valid  for  SLIPCOVER):
     maximum number of distinct variables in a clause
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">verbosity</span></span></span> (values: integer in [1,3], default value: 1): level of verbosity of
     the algorithms
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">beamsize</span></span></span> (values: integer, default value: 100, valid for SLIPCOVER): size
     of the beam
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">megaex_bottom</span></span></span> (values: integer, default value: 1, valid for SLIPCOVER):
     number of mega-examples on which to build the bottom clauses
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">initial_clauses_per_megaex</span></span></span> (values: integer, default value: 1, valid for
     SLIPCOVER): number of bottom clauses to build for each mega-example
     (or model or interpretation)
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">d</span></span></span> (values: integer, default value: 1, valid for SLIPCOVER): number of
     saturation steps when building the bottom clause
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">max_iter_structure</span></span></span> (values:  integer,  default  value:  10000,  valid  for
     SLIPCOVER): maximum number of theory search iterations
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">background_clauses</span></span></span>  (values:   integer,   default   value:   50,   valid   for
     SLIPCOVER): maximum numbers of background clauses
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">maxdepth_var</span></span></span> (values: integer, default value: 2, valid for SLIPCOVER):
     maximum depth of variables in clauses (as defined in <span class="cite">[<a 
href="#XDBLP:journals/ai/Cohen95">5</a>]</span>).

     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">neg_ex</span></span></span> (values: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">given</span></span></span>, <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">cw</span></span></span>, default value: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">cw</span></span></span>): if set to <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">given</span></span></span>, the negative
     examples in testing are taken from the test folds interpretations, i.e., those
     example <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">ex</span></span></span> stored as <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">neg(ex)</span></span></span>; if set to <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">cw</span></span></span>, the negative examples are
     generated according to the closed world assumption, i.e., all atoms for
     target predicates that are not positive examples. The set of all atoms is
     obtained by collecting the set of constants for each type of the arguments
     of the target predicate.</li></ul>
<!--l. 492--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.3   </span> <a 
 id="x1-140005.3"></a>Commands</h4>
<!--l. 493--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.3.1   </span> <a 
 id="x1-150005.3.1"></a>Parameter Learning</h5>
<!--l. 494--><p class="noindent" >To execute EMBLEM, prepare an input file as indicated above (for example
<span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">bongard.pl</span></span></span>, load it into SWI-Prolog

   <div class="verbatim" id="verbatim-43">
?-&#x00A0;[bongard].
</div>
<!--l. 498--><p class="nopar" > and call

   <div class="verbatim" id="verbatim-44">
?-&#x00A0;induce_par([train],P).
</div>
<!--l. 502--><p class="nopar" > to obtain in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">P</span></span></span> the program in input with the updated parameters.
<!--l. 505--><p class="indent" >   The results can also be tested on a test set with

   <div class="verbatim" id="verbatim-45">
?-&#x00A0;induce_par([train],[test],P,LL,AUCROC,ROC,AUCPR,PR).
</div>
<!--l. 508--><p class="nopar" > returning the log likelihood of the test examples in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">LL</span></span></span>, the Area Under the ROC
curve in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">AUCROC</span></span></span>, the list of points (in the form of Prolog pairs <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">x-y</span></span></span>) of the ROC curve
in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">ROC</span></span></span>, the Area Under the PR curve in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">AUCPR</span></span></span>, the list of points of the PR curve in
<span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">PR</span></span></span>.
<!--l. 512--><p class="indent" >   The general form of the commands is

   <div class="verbatim" id="verbatim-46">
?-&#x00A0;induce_par(&#x003C;list_of_train_folds&#x003E;,P).
</div>
<!--l. 515--><p class="nopar" >

   <div class="verbatim" id="verbatim-47">
?-&#x00A0;induce_par(&#x003C;list_of_train_folds&#x003E;,&#x003C;list_of_test_folds&#x003E;,
&#x00A0;<br />&#x00A0;&#x00A0;P,LL,AUCROC,ROC,AUCPR,PR).
</div>
<!--l. 519--><p class="nopar" >
<!--l. 521--><p class="noindent" >
   <h5 class="subsubsectionHead"><span class="titlemark">5.3.2   </span> <a 
 id="x1-160005.3.2"></a>Structure Learning</h5>
<!--l. 522--><p class="noindent" >To execute SLIPCOVER, prepare an input file as indicated above (for example
<span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">bongard.pl</span></span></span>, load it into SWI-Prolog

   <div class="verbatim" id="verbatim-48">
?-&#x00A0;[bongard].
</div>
<!--l. 527--><p class="nopar" > and call

   <div class="verbatim" id="verbatim-49">
?-&#x00A0;induce([train],P).
</div>
<!--l. 531--><p class="nopar" > to obtain in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">P</span></span></span> the learned program.
<!--l. 534--><p class="indent" >   The results can also be tested on a test set with

   <div class="verbatim" id="verbatim-50">
?-&#x00A0;induce([train],[test],P,LL,AUCROC,ROC,AUCPR,PR).
</div>
<!--l. 537--><p class="nopar" > returning the log likelihood of the test examples in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">LL</span></span></span>, the Area Under the ROC
curve in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">AUCROC</span></span></span>, the list of points (in the form of Prolog pairs <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">x-y</span></span></span>) of the ROC curve
in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">ROC</span></span></span>, the Area Under the PR curve in <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">AUCPR</span></span></span>, the list of points of the PR curve in
<span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">PR</span></span></span>.
<!--l. 541--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.4   </span> <a 
 id="x1-170005.4"></a>Files</h4>
<!--l. 542--><p class="noindent" >The <span 
class="cmtt-10">pack/cplint/prolog/examples </span>folder in SWI-Prolog home contains some
example programs. The subfolder <span 
class="cmtt-10">learning </span>contains some learning examples. The
<span 
class="cmtt-10">pack/cplint/doc </span>folder in SWI-Prolog home contains this manual in latex, html and
pdf.
<!--l. 546--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">6   </span> <a 
 id="x1-180006"></a>License</h3>
<!--l. 551--><p class="noindent" ><span 
class="cmtt-10">cplint </span>follows the Artistic License 2.0 that you can find in <span 
class="cmtt-10">cplint </span>root folder. The
copyright is by Fabrizio Riguzzi.
<!--l. 555--><p class="indent" >   The library <a 
href="http://vlsi.colorado.edu/~fabio/" > CUDD </a> for manipulating BDDs has the following license:
<!--l. 559--><p class="indent" >   Copyright (c) 1995-2004, Regents of the University of Colorado
<!--l. 561--><p class="indent" >   All rights reserved.
<!--l. 563--><p class="indent" >   Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
     <ul class="itemize1">
     <li class="itemize">Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
     </li>
     <li class="itemize">Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
     </li>
     <li class="itemize">Neither  the  name  of  the  University  of  Colorado  nor  the  names  of  its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.</li></ul>

<!--l. 580--><p class="noindent" >THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS <br 
class="newline" />AND CONTRIBUTORS &#8221;AS IS&#8221; AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAU-SED <br 
class="newline" />AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<!--l. 1--><p class="noindent" >
   <h3 class="likesectionHead"><a 
 id="x1-190006"></a>References</h3>
<!--l. 1--><p class="noindent" >
    <div class="thebibliography">
    <p class="bibitem" ><span class="biblabel">
  [1]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XBelRig11-CILC11-NC"></a>Elena Bellodi and Fabrizio Riguzzi. EM over binary decision diagrams
    for  probabilistic  logic  programs.    In  <span 
class="cmti-10">Proceedings  of  the  26th  Italian</span>
    <span 
class="cmti-10">Conference on Computational Logic (CILC2011), Pescara, Italy, 31 August</span>
    <span 
class="cmti-10">31-2 September, 2011</span>, 2011.
    </p>
    <p class="bibitem" ><span class="biblabel">
  [2]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XBelRig11-TR"></a>Elena  Bellodi  and  Fabrizio  Riguzzi.     EM  over  binary  decision
    diagrams for probabilistic logic programs.  Technical Report CS-2011-01,
    Dipartimento di Ingegneria, Università di Ferrara, Italy, 2011.
    </p>
    <p class="bibitem" ><span class="biblabel">
  [3]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XBelRig11-IDA"></a>Elena Bellodi and Fabrizio Riguzzi.  Expectation Maximization over
    binary decision diagrams for probabilistic logic programs. <span 
class="cmti-10">Intel. Data Anal.</span>,
    16(6), 2012.
    </p>
    <p class="bibitem" ><span class="biblabel">
  [4]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XBelRig13-TPLP-IJ"></a>Elena Bellodi and Fabrizio Riguzzi. Structure learning of probabilistic
    logic programs by searching the clause space. <span 
class="cmti-10">Theory and Practice of Logic</span>
    <span 
class="cmti-10">Programming</span>, 2013.

    </p>
    <p class="bibitem" ><span class="biblabel">
  [5]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XDBLP:journals/ai/Cohen95"></a>William&#x00A0;W. Cohen.  Pac-learning non-recursive prolog clauses.  <span 
class="cmti-10">Artif.</span>
    <span 
class="cmti-10">Intell.</span>, 79(1):1&#8211;38, 1995.
    </p>
    <p class="bibitem" ><span class="biblabel">
  [6]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XRaeLae95-ALT95"></a>L.&#x00A0;De&#x00A0;Raedt  and  W.&#x00A0;Van&#x00A0;Laer.    Inductive  constraint  logic.    In
    <span 
class="cmti-10">Proceedings of the 6th Conference on Algorithmic Learning Theory (ALT</span>
    <span 
class="cmti-10">1995)</span>, volume 997 of <span 
class="cmti-10">LNAI</span>, pages 80&#8211;94, Fukuoka, Japan, 1995. Springer.
    </p>
    <p class="bibitem" ><span class="biblabel">
  [7]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XRigSwi10-ICLP10-IC"></a>Fabrizio   Riguzzi   and   Terrance   Swift.       Tabling   and   Answer
    Subsumption   for   Reasoning   on   Logic   Programs   with   Annotated
    Disjunctions. In <span 
class="cmti-10">Technical Communications of the International Conference</span>
    <span 
class="cmti-10">on Logic Programming</span>, volume&#x00A0;7 of <span 
class="cmti-10">Leibniz International Proceedings in</span>
    <span 
class="cmti-10">Informatics (LIPIcs)</span>, pages 162&#8211;171. Schloss Dagstuhl&#8211;Leibniz-Zentrum
    fuer Informatik, 2010.
    </p>
    <p class="bibitem" ><span class="biblabel">
  [8]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XVenDenBru-JELIA06"></a>J.&#x00A0;Vennekens, M.&#x00A0;Denecker, and M.&#x00A0;Bruynooghe. Representing causal
    information  about  a  probabilistic  process.   In  <span 
class="cmti-10">Proceedings  of  the  10th</span>
    <span 
class="cmti-10">European Conference on Logics in Artificial Intelligence</span>, LNAI. Springer,
    September 2006.
    </p>
    <p class="bibitem" ><span class="biblabel">
  [9]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XDBLP:journals/tplp/VennekensDB09"></a>J.&#x00A0;Vennekens,  Marc  Denecker,  and  Maurice  Bruynooghe.   CP-logic:
    A  language  of  causal  probabilistic  events  and  its  relation  to  logic
    programming. <span 
class="cmti-10">Theory Pract. Log. Program.</span>, 9(3):245&#8211;308, 2009.
    </p>
    <p class="bibitem" ><span class="biblabel">
 [10]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XVenVer03-TR"></a>J.&#x00A0;Vennekens  and  S.&#x00A0;Verbaeten.    Logic  programs  with  annotated
    disjunctions. Technical Report CW386, K. U. Leuven, 2003.
    </p>
    <p class="bibitem" ><span class="biblabel">
 [11]<span class="bibsp">&#x00A0;&#x00A0;&#x00A0;</span></span><a 
 id="XVenVer04-ICLP04-IC"></a>J.&#x00A0;Vennekens,  S.&#x00A0;Verbaeten,  and  M.&#x00A0;Bruynooghe.   Logic  programs
    with  annotated  disjunctions.     In  <span 
class="cmti-10">International  Conference  on  Logic</span>
    <span 
class="cmti-10">Programming</span>, volume 3131 of <span 
class="cmti-10">LNCS</span>, pages 195&#8211;209. Springer, 2004.
</p>
    </div>
    
</body></html> 



