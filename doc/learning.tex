\section{Learning}
\label{learning}
The following learning algorithms are available:
\begin{itemize}
\item EMBLEM (EM over Bdds for probabilistic Logic programs Efficient Mining): an implementation of EM for learning parameters that computes expectations directly on BDDs \cite{BelRig11-IDA}, \cite{BelRig11-CILC11-NC}, \cite{BelRig11-TR}
\item SLIPCOVER (Structure LearnIng of Probabilistic logic programs by searChing OVER the clause space): an algorithm for learning the structure of programs by searching the clause space and the theory space separately \cite{BelRig13-TPLP-IJ}
\end{itemize}

\subsection{Input}
To execute the learning algorithms, prepare a Prolog file divided in five parts
\begin{itemize}
\item preamble
\item  background knowledge, i.e., knowledge valid for all interpretations
\item  LPAD/CPL-program for you which you want to learn the parameters (optional)
\item language bias information
\item  example interpretations 
\end{itemize}
The preamble must come first, the order of the other parts can be changed.

For example, consider the Bongard problems of \cite{RaeLae95-ALT95}. 
The \texttt{pack/cplint/ prolog/examples/learning} folder in SWI-Prolog home contains some example learning files. 
For example, it contains \verb|bongard.pl| and \verb|bongardkeys.pl| that represent a Bongard problem.
Let us consider \verb|bongard.pl|.

\subsubsection{Preamble}
In the preamble, the SLIPCOVER library is loaded with
\begin{verbatim}
:- use_module(library(slipcover)).
\end{verbatim}
Then, if you are using your file in cplint on SWISH, you could add
\begin{verbatim}
:- if(current_predicate(use_rendering/1)).
:- use_rendering(c3).
:- use_rendering(lpad).
:- endif.
\end{verbatim}
if you want a nice representation of the output (in particular, if you want graphs of the ROC and PR curves).

Now you can initialize SLIPCOVER with
\begin{verbatim}
:- sc.
\end{verbatim}
At this point you can start setting parameters for SLIPCOVER such as for example
\begin{verbatim}
:- set_sc(megaex_bottom,20).
:- set_sc(max_iter,2).
:- set_sc(max_iter_structure,5).
:- set_sc(verbosity,1).
\end{verbatim}
We will see later the list of available parameters.
This ends the preamble.

\subsubsection{Backgroung and Initial LPAD/CPL-program}
%
Now you can specify the background knowledge with a 
fact of the form 
\begin{verbatim}
bg(<list of terms representing clauses>).
\end{verbatim}
and an initial program with a fact of the form 
\begin{verbatim}
in(<list of terms representing clauses>).
\end{verbatim}
The initial program is used in parameter learning for providing 
the structure. The indicated parameters do not matter as they are first randomized.
Remember to enclose each clause in parentheses because \verb|:-| has the highest precedence.

For example, \verb|bongard.pl| has the initial program 
\begin{verbatim}
in([(pos:0.197575 :-
       circle(A),
       in(B,A)),
    (pos:0.000303421 :-
       circle(A),
       triangle(B)), 
    (pos:0.000448807 :-
       triangle(A),
       circle(B))]).
\end{verbatim}
Both facts should be present. If there are no background/input clauses then write \verb|bg([]).|/\verb|in([]).|


\subsubsection{Language Bias}
%
The language bias part contains the declarations of the input and output predicates.
Output predicates are declared as
\begin{verbatim}
output(<predicate>/<arity>).
\end{verbatim}
and indicate the predicate whose atoms you want to predict. Derivations for the atoms for this predicates in the input data
are built by the systems.

Input predicates are those whose atoms you are not interested in predicting. You can declare closed world input predicates with
\begin{verbatim}
input_cw(<predicate>/<arity>).
\end{verbatim}
For these predicates, the only true atoms are those in the interpretations, the clauses in the input/hypothesized program are not used to derive atoms not present in the interpretations.

Open world input predicates are declared with
\begin{verbatim}
input(<predicate>/<arity>).
\end{verbatim}
In this case, if a subgoal for such a predicate is encountered when deriving a subgoal for the output predicates, 
both the facts in the interpretations and the clauses of the input program are used.

Then, you have to specify the language bias by means of mode declarations in the style of 
\href{http://www.doc.ic.ac.uk/\string ~shm/progol.html}{Progol}.
\begin{verbatim}
modeh(<recall>,<predicate>(<arg1>,...).
\end{verbatim}
specifies the atoms that can appear in the head of clauses, while
\begin{verbatim}
modeb(<recall>,<predicate>(<arg1>,...).
\end{verbatim}
specifies the atoms that can appear in the body of clauses.
\texttt{<recall>} can be an integer or \texttt{*}.
\texttt{<recall>} indicates how many atoms for the predicate specification are
retained in the bottom clause during a saturation step. \texttt{*} stands for all those that are found. Otherwise the indicated number is randomly chosen.

Arguments of the form
\begin{verbatim}
+<type>
\end{verbatim}
specifies that the argument should be an input variable of type \texttt{<type>}, i.e., a variable replacing a \texttt{+<type>} argument in the head or a \texttt{-<type>} argument in a preceding literal in the current hypothesized clause.

Another argument form is
\begin{verbatim}
-<type>
\end{verbatim}
for specifying that the argument should be a output variable of type \texttt{<type>}. 
Any variable can replace this argument, either input or output.
The only constraint on output variables is that those in the head of the current hypothesized 
clause must appear as output variables in an atom of the body.

Other forms are
\begin{verbatim}
#<type>
\end{verbatim}
for specifying an argument which should be replaced by a constant of type \texttt{<type>} in the bottom clause but should not be used for replacing input variables of the following literals when building the bottom clause or 
\begin{verbatim}
-#<type>
\end{verbatim}
for specifying an argument which should be replaced by a constant of type \texttt{<type>} in the bottom clause and that should be used for replacing input variables of the following literals when building the bottom clause. 
%\verb|#| and \verb|-#| differ only in the creation of the bottom clause.
\begin{verbatim}
<constant>
\end{verbatim}
for specifying a constant.

An example of language bias for the Bongard domain is
\begin{verbatim}
output(pos/0).

input_cw(triangle/1).
input_cw(square/1).
input_cw(circle/1).
input_cw(in/2).
input_cw(config/2).

modeh(*,pos).
modeb(*,triangle(-obj)).
modeb(*,square(-obj)).
modeb(*,circle(-obj)).
modeb(*,in(+obj,-obj)).
modeb(*,in(-obj,+obj)).
modeb(*,config(+obj,-#dir)).
\end{verbatim}
SLIPCOVER also requires facts for the \verb|determination/2| predicate  Aleph-style that indicate which predicates can appear in the body of clauses. 
For example
\begin{verbatim}
determination(pos/0,triangle/1).
determination(pos/0,square/1).
determination(pos/0,circle/1).
determination(pos/0,in/2).
determination(pos/0,config/2).
\end{verbatim}
state that \verb|triangle/1| can appear in the body of clauses for \verb|pos/0|.

SLIPCOVER also allows mode declarations of the form
\begin{verbatim}
modeh(<r>,[<s1>,...,<sn>],[<a1>,...,<an>],[<P1/Ar1>,...,<Pk/Ark>]). 
\end{verbatim}
These mode declarations are used to generate clauses with more than two head atoms. In them, \verb|<s1>,...,<sn>| are schemas,  \verb|<a1>,...,<an>| are atoms such that \verb|<ai>| is obtained from $\verb|<si>|$ by replacing placemarkers with variables, 
\verb|<Pi/Ari>| are the predicates admitted in the body. \verb|<a1>,...,<an>| are used to indicate which variables should be shared by the atoms in the head.
An example of such a mode declaration (from \verb|uwcselearn.pl|) is
\begin{verbatim}
modeh(*,
[advisedby(+person,+person),tempadvisedby(+person,+person)],
[advisedby(A,B),tempadvisedby(A,B)],
[professor/1,student/1,hasposition/2,inphase/2,
publication/2,taughtby/3,ta/3,courselevel/2,yearsinprogram/2]).
\end{verbatim}

\subsubsection{Example Interpretations}
The last part of the file contains the data.
You can specify data with two modalities:
models and keys.
In the models type, you specify an example model (or interpretation or megaexample) as a list of Prolog facts initiated by 
\texttt{begin(model(<name>)).} and terminated by \texttt{end(model(<name>)).} as in
\begin{verbatim}
begin(model(2)).
pos.
triangle(o5).
config(o5,up).
square(o4).
in(o4,o5).
circle(o3).
triangle(o2).
config(o2,up).
in(o2,o3).
triangle(o1).
config(o1,up).
end(model(2)).
\end{verbatim}
The interpretations may contain a fact of the form
\begin{verbatim}
prob(0.3).
\end{verbatim}
assigning a probability (0.3 in this case) to the interpretations. If this is omitted, the probability of each interpretation is considered equal to $1/n$ where $n$ is the total number of interpretations. \verb|prob/1| can be used to set a different multiplicity for the interpretations.

The facts in the interpretation are loaded in SWI-Prolog database by adding an extra initial argument equal to the name of the model.

Alternatively, with the keys modality, you can directly write the facts and the first argument will be interpreted as a model identifier. The above interpretation in the keys modality is
\begin{verbatim}
pos(2).
triangle(2,o5).
config(2,o5,up).
square(2,o4).
in(2,o4,o5).
circle(2,o3).
triangle(2,o2).
config(2,o2,up).
in(2,o2,o3).
triangle(2,o1).
config(2,o1,up).
\end{verbatim}
which is contained in the \verb|bongardkeys.pl|
This is also how model \verb|2| above is stored in SWI-Prolog database.
The two modalities, models and keys, can be mixed in the same file.

Note that you can add background knowledge that is not probabilistic directly to the file writing the clauses taking into account the model argument. For example \verb|carc.pl|
contains

\begin{verbatim}
connected(_M,Ring1,Ring2):-
  Ring1 \= Ring2,
  member(A,Ring1),
  member(A,Ring2), !.

symbond(Mod,A,B,T):- bond(Mod,A,B,T).
symbond(Mod,A,B,T):- bond(Mod,B,A,T).
\end{verbatim}
where the first argument of all the atoms is the model.

Then you must indicate how the examples are divided in folds with facts of the form:
\verb|fold(<fold_name>,<list of model identifiers>)|, as for example
\begin{verbatim}
fold(train,[2,3,...]).
fold(test,[490,491,...]).
\end{verbatim}
